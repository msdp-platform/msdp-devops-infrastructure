name: Deploy Backstage

on:
  push:
    branches: [main, develop]
    paths:
      - "infrastructure/crossplane/**"
      - "infrastructure/kubernetes/backstage/**"
      - "infrastructure/argocd/applications/backstage-application.yaml"
      - ".github/workflows/deploy-backstage.yml"
  pull_request:
    branches: [main]
    paths:
      - "infrastructure/crossplane/**"
      - "infrastructure/kubernetes/backstage/**"
      - "infrastructure/argocd/applications/backstage-application.yaml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      business_unit:
        description: "Business Unit"
        required: true
        default: "platform-core"
        type: choice
        options:
          - platform-core
          - food-delivery
          - grocery-delivery
          - cleaning-services
          - repair-services
      country:
        description: "Country"
        required: true
        default: "global"
        type: choice
        options:
          - global
          - uk
          - india
      dry_run:
        description: "Perform dry run"
        required: false
        default: false
        type: boolean

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  KUBECONFIG: /tmp/kubeconfig

jobs:
  # Job to determine deployment parameters
  determine-params:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.params.outputs.environment }}
      business_unit: ${{ steps.params.outputs.business_unit }}
      country: ${{ steps.params.outputs.country }}
      dry_run: ${{ steps.params.outputs.dry_run }}
      should_deploy: ${{ steps.params.outputs.should_deploy }}
    steps:
      - name: Determine deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "business_unit=${{ github.event.inputs.business_unit }}" >> $GITHUB_OUTPUT
            echo "country=${{ github.event.inputs.country }}" >> $GITHUB_OUTPUT
            echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "push" ]; then
            # Determine environment based on branch
            if [ "${{ github.ref }}" = "refs/heads/main" ]; then
              echo "environment=prod" >> $GITHUB_OUTPUT
            elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
              echo "environment=staging" >> $GITHUB_OUTPUT
            else
              echo "environment=dev" >> $GITHUB_OUTPUT
            fi
            echo "business_unit=platform-core" >> $GITHUB_OUTPUT
            echo "country=global" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # Job to validate and lint configuration files
  validate-config:
    runs-on: ubuntu-latest
    needs: determine-params
    if: needs.determine-params.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup YAML lint
        run: |
          pip install yamllint

      - name: Lint YAML files
        run: |
          yamllint infrastructure/crossplane/
          yamllint infrastructure/kubernetes/backstage/
          yamllint infrastructure/argocd/

      - name: Validate Crossplane XRD
        run: |
          # Check if XRD file is valid YAML
          python -c "import yaml; yaml.safe_load(open('infrastructure/crossplane/xrds/backstage-xrd.yaml'))"
          echo "✅ XRD file is valid YAML"

      - name: Validate Crossplane Composition
        run: |
          # Check if composition file is valid YAML
          python -c "import yaml; yaml.safe_load(open('infrastructure/crossplane/compositions/backstage-composition.yaml'))"
          echo "✅ Composition file is valid YAML"

      - name: Validate Helm Chart
        run: |
          # Check if Chart.yaml is valid
          python -c "import yaml; yaml.safe_load(open('infrastructure/kubernetes/backstage/Chart.yaml'))"
          echo "✅ Helm Chart is valid"

      - name: Validate ArgoCD Application
        run: |
          # Check if ArgoCD application is valid YAML
          python -c "import yaml; yaml.safe_load(open('infrastructure/argocd/applications/backstage-application.yaml'))"
          echo "✅ ArgoCD Application is valid"

  # Job to setup Azure and Kubernetes
  setup-environment:
    runs-on: ubuntu-latest
    needs: [determine-params, validate-config]
    if: needs.determine-params.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --file $KUBECONFIG

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: "latest"

      - name: Install Crossplane CLI
        run: |
          curl -sL https://raw.githubusercontent.com/crossplane/crossplane/release-1.14/install.sh | sh
          sudo mv kubectl-crossplane /usr/local/bin/

  # Job to deploy Crossplane infrastructure
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [determine-params, setup-environment]
    if: needs.determine-params.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-params.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --file $KUBECONFIG

      - name: Install Crossplane CLI
        run: |
          curl -sL https://raw.githubusercontent.com/crossplane/crossplane/release-1.14/install.sh | sh
          sudo mv kubectl-crossplane /usr/local/bin/

      - name: Check if XRD exists
        run: |
          if ! kubectl get crd xbackstageinfrastructures.msdp.io; then
            echo "Installing Crossplane XRD..."
            kubectl apply -f infrastructure/crossplane/xrds/backstage-xrd.yaml
            echo "✅ XRD installed"
          else
            echo "✅ XRD already exists"
          fi

      - name: Check if Composition exists
        run: |
          if ! kubectl get composition backstage-infrastructure; then
            echo "Installing Crossplane Composition..."
            kubectl apply -f infrastructure/crossplane/compositions/backstage-composition.yaml
            echo "✅ Composition installed"
          else
            echo "✅ Composition already exists"
          fi

      - name: Create secrets
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          BU="${{ needs.determine-params.outputs.business_unit }}"
          COUNTRY="${{ needs.determine-params.outputs.country }}"
          SECRET_NAME="backstage-${ENV}-${BU}-${COUNTRY}-secrets"

          if ! kubectl get secret "$SECRET_NAME" -n crossplane-system; then
            echo "Creating secret: $SECRET_NAME"
            kubectl create secret generic "$SECRET_NAME" \
              --namespace=crossplane-system \
              --from-literal=postgres-password="$(openssl rand -base64 32)" \
              --from-literal=github-token="${{ secrets.GITHUB_TOKEN }}" \
              --from-literal=azure-token="${{ secrets.AZURE_CLIENT_SECRET }}" \
              --from-literal=argocd-password="${{ secrets.ARGOCD_PASSWORD }}" \
              --from-literal=session-secret="$(openssl rand -base64 32)"
            echo "✅ Secret created"
          else
            echo "✅ Secret already exists"
          fi

      - name: Deploy infrastructure claim
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          BU="${{ needs.determine-params.outputs.business_unit }}"
          COUNTRY="${{ needs.determine-params.outputs.country }}"
          CLAIM_NAME="backstage-${ENV}-${BU}-${COUNTRY}"

          # Create claim file
          cat > /tmp/backstage-claim.yaml << EOF
          apiVersion: msdp.io/v1alpha1
          kind: XBackstageInfrastructure
          metadata:
            name: $CLAIM_NAME
            namespace: crossplane-system
            labels:
              environment: $ENV
              business-unit: $BU
              country: $COUNTRY
              service: backstage
          spec:
            environment: "$ENV"
            businessUnit: "$BU"
            country: "$COUNTRY"
            location: "UK South"
            resourceGroupName: "msdp-${ENV}-rg"
            tenantId: "${{ secrets.AZURE_TENANT_ID }}"
            postgresAdminUser: "backstageadmin"
            postgresPasswordSecret: "backstage-postgres-password-${ENV}"
            postgresSku: "$(if [ "$ENV" = "prod" ]; then echo "GP_Standard_D2s_v3"; else echo "B_Standard_B1ms"; fi)"
            postgresVersion: "13"
            postgresStorageMb: $(if [ "$ENV" = "prod" ]; then echo "131072"; else echo "32768"; fi)
            postgresBackupRetentionDays: $(if [ "$ENV" = "prod" ]; then echo "30"; else echo "3"; fi)
            postgresGeoRedundantBackup: $(if [ "$ENV" = "prod" ]; then echo "true"; else echo "false"; fi)
            postgresCharset: "UTF8"
            postgresCollation: "en_US.utf8"
            postgresStartIp: "0.0.0.0"
            postgresEndIp: "255.255.255.255"
            storageAccountTier: "Standard"
            storageAccountReplication: "$(if [ "$ENV" = "prod" ]; then echo "GRS"; else echo "LRS"; fi)"
            storageAccountKind: "StorageV2"
            storageMinTlsVersion: "TLS1_2"
            storageAllowPublic: false
            storageContainerAccessType: "private"
            keyVaultSku: "$(if [ "$ENV" = "prod" ]; then echo "premium"; else echo "standard"; fi)"
            keyVaultDiskEncryption: true
            keyVaultTemplateDeployment: true
            keyVaultRbacAuth: true
            keyVaultPurgeProtection: $(if [ "$ENV" = "prod" ]; then echo "true"; else echo "false"; fi)
            appInsightsType: "web"
            appInsightsRetentionDays: $(if [ "$ENV" = "prod" ]; then echo "365"; else echo "30"; fi)
            appInsightsDailyDataCap: $(if [ "$ENV" = "prod" ]; then echo "10"; else echo "0.1"; fi)
            appInsightsDataCapNotificationsDisabled: $(if [ "$ENV" = "prod" ]; then echo "false"; else echo "true"; fi)
          EOF

          if [ "${{ needs.determine-params.outputs.dry_run }}" = "true" ]; then
            echo "🔍 Dry run: Would apply Crossplane claim:"
            cat /tmp/backstage-claim.yaml
          else
            kubectl apply -f /tmp/backstage-claim.yaml
            echo "✅ Applied Crossplane claim: $CLAIM_NAME"
            
            # Wait for infrastructure to be ready
            echo "⏳ Waiting for infrastructure to be ready..."
            kubectl wait --for=condition=Ready xbackstageinfrastructure/$CLAIM_NAME -n crossplane-system --timeout=600s
            echo "✅ Infrastructure is ready"
          fi

  # Job to deploy ArgoCD application
  deploy-application:
    runs-on: ubuntu-latest
    needs: [determine-params, deploy-infrastructure]
    if: needs.determine-params.outputs.should_deploy == 'true' && needs.determine-params.outputs.dry_run == 'false'
    environment: ${{ needs.determine-params.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --file $KUBECONFIG

      - name: Get infrastructure connection details
        id: infra-details
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          BU="${{ needs.determine-params.outputs.business_unit }}"
          COUNTRY="${{ needs.determine-params.outputs.country }}"
          CLAIM_NAME="backstage-${ENV}-${BU}-${COUNTRY}"

          # Get connection details from Crossplane
          kubectl get secret "backstage-${ENV}-${BU}-${COUNTRY}-secrets" -n crossplane-system -o jsonpath='{.data}' > /tmp/connection-details.json

          # Extract values (these would be populated by Crossplane)
          echo "postgres_host=placeholder-postgres-host" >> $GITHUB_OUTPUT
          echo "postgres_port=5432" >> $GITHUB_OUTPUT
          echo "postgres_database=backstage_plugin_catalog" >> $GITHUB_OUTPUT
          echo "postgres_user=backstageadmin" >> $GITHUB_OUTPUT
          echo "storage_account_name=placeholder-storage-account" >> $GITHUB_OUTPUT
          echo "storage_container_name=backstage-files" >> $GITHUB_OUTPUT
          echo "key_vault_uri=https://placeholder-keyvault.vault.azure.net/" >> $GITHUB_OUTPUT
          echo "app_insights_connection_string=placeholder-connection-string" >> $GITHUB_OUTPUT
          echo "app_insights_instrumentation_key=placeholder-instrumentation-key" >> $GITHUB_OUTPUT

      - name: Deploy ArgoCD application
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          BU="${{ needs.determine-params.outputs.business_unit }}"
          COUNTRY="${{ needs.determine-params.outputs.country }}"
          APP_NAME="backstage-${ENV}-${BU}-${COUNTRY}"
          NAMESPACE="backstage-${ENV}"

          # Create ArgoCD application file
          cat > /tmp/backstage-app.yaml << EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: $APP_NAME
            namespace: argocd
            labels:
              environment: $ENV
              business-unit: $BU
              country: $COUNTRY
              service: backstage
              managed-by: argocd
            finalizers:
              - resources-finalizer.argocd.argoproj.io
          spec:
            project: msdp-platform
            source:
              repoURL: "${{ github.server_url }}/${{ github.repository }}"
              targetRevision: "${{ github.ref_name }}"
              path: "infrastructure/kubernetes/backstage/$ENV/$BU/$COUNTRY"
              helm:
                valueFiles:
                  - "values-$ENV.yaml"
                  - "values-$BU.yaml"
                  - "values-$COUNTRY.yaml"
                parameters:
                  - name: "environment"
                    value: "$ENV"
                  - name: "businessUnit"
                    value: "$BU"
                  - name: "country"
                    value: "$COUNTRY"
                  - name: "namespace"
                    value: "$NAMESPACE"
                  - name: "postgres.host"
                    value: "${{ steps.infra-details.outputs.postgres_host }}"
                  - name: "postgres.port"
                    value: "${{ steps.infra-details.outputs.postgres_port }}"
                  - name: "postgres.database"
                    value: "${{ steps.infra-details.outputs.postgres_database }}"
                  - name: "postgres.user"
                    value: "${{ steps.infra-details.outputs.postgres_user }}"
                  - name: "storage.accountName"
                    value: "${{ steps.infra-details.outputs.storage_account_name }}"
                  - name: "storage.containerName"
                    value: "${{ steps.infra-details.outputs.storage_container_name }}"
                  - name: "keyVault.uri"
                    value: "${{ steps.infra-details.outputs.key_vault_uri }}"
                  - name: "appInsights.connectionString"
                    value: "${{ steps.infra-details.outputs.app_insights_connection_string }}"
                  - name: "appInsights.instrumentationKey"
                    value: "${{ steps.infra-details.outputs.app_insights_instrumentation_key }}"
                  - name: "backstage.app.title"
                    value: "MSDP Developer Portal - $ENV - $BU - $COUNTRY"
                  - name: "backstage.app.baseUrl"
                    value: "https://backstage.$ENV.msdp.com"
                  - name: "backstage.backend.baseUrl"
                    value: "https://backstage-api.$ENV.msdp.com"
                  - name: "backstage.organization.name"
                    value: "MSDP Platform - $ENV"
                  - name: "backstage.organization.logo"
                    value: "/logo-$ENV.png"
                  - name: "backstage.businessUnit"
                    value: "$BU"
                  - name: "backstage.country"
                    value: "$COUNTRY"
                  - name: "backstage.supportedBusinessUnits"
                    value: "food-delivery,grocery-delivery,cleaning-services,repair-services"
                  - name: "backstage.supportedCountries"
                    value: "uk,india"
                  - name: "backstage.auth.providers"
                    value: "github,microsoft"
                  - name: "backstage.auth.session.secret"
                    value: "${{ secrets.SESSION_SECRET }}"
                  - name: "backstage.integrations.github"
                    value: "${{ secrets.GITHUB_INTEGRATION }}"
                  - name: "backstage.integrations.azure"
                    value: "${{ secrets.AZURE_INTEGRATION }}"
                  - name: "backstage.integrations.argocd"
                    value: "${{ secrets.ARGOCD_INTEGRATION }}"
            destination:
              server: https://kubernetes.default.svc
              namespace: "$NAMESPACE"
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
                allowEmpty: false
              syncOptions:
                - CreateNamespace=true
                - PrunePropagationPolicy=foreground
                - PruneLast=true
              retry:
                limit: 5
                backoff:
                  duration: 5s
                  factor: 2
                  maxDuration: 3m
            revisionHistoryLimit: 10
          EOF

          kubectl apply -f /tmp/backstage-app.yaml
          echo "✅ Applied ArgoCD application: $APP_NAME"

          # Wait for application to be synced
          echo "⏳ Waiting for application to be synced..."
          kubectl wait --for=condition=Synced application/$APP_NAME -n argocd --timeout=300s
          echo "✅ Application is synced"

  # Job to verify deployment
  verify-deployment:
    runs-on: ubuntu-latest
    needs: [determine-params, deploy-application]
    if: needs.determine-params.outputs.should_deploy == 'true' && needs.determine-params.outputs.dry_run == 'false'
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --file $KUBECONFIG

      - name: Verify Crossplane infrastructure
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          BU="${{ needs.determine-params.outputs.business_unit }}"
          COUNTRY="${{ needs.determine-params.outputs.country }}"
          CLAIM_NAME="backstage-${ENV}-${BU}-${COUNTRY}"

          echo "🔍 Crossplane Infrastructure Status:"
          kubectl get xbackstageinfrastructure -n crossplane-system -l environment=$ENV,business-unit=$BU,country=$COUNTRY
          echo

          echo "🔍 Infrastructure Details:"
          kubectl describe xbackstageinfrastructure $CLAIM_NAME -n crossplane-system

      - name: Verify ArgoCD application
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          BU="${{ needs.determine-params.outputs.business_unit }}"
          COUNTRY="${{ needs.determine-params.outputs.country }}"
          APP_NAME="backstage-${ENV}-${BU}-${COUNTRY}"

          echo "🔍 ArgoCD Application Status:"
          kubectl get application -n argocd -l environment=$ENV,business-unit=$BU,country=$COUNTRY
          echo

          echo "🔍 Application Details:"
          kubectl describe application $APP_NAME -n argocd

      - name: Verify Backstage pods
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          NAMESPACE="backstage-${ENV}"

          echo "🔍 Backstage Pods:"
          kubectl get pods -n $NAMESPACE -l app=backstage
          echo

          echo "🔍 Pod Details:"
          kubectl describe pods -n $NAMESPACE -l app=backstage

      - name: Verify Backstage services
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          NAMESPACE="backstage-${ENV}"

          echo "🔍 Backstage Services:"
          kubectl get services -n $NAMESPACE -l app=backstage
          echo

          echo "🔍 Backstage Ingress:"
          kubectl get ingress -n $NAMESPACE -l app=backstage

      - name: Health check
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          NAMESPACE="backstage-${ENV}"

          echo "🔍 Health Check:"
          kubectl get pods -n $NAMESPACE -l app=backstage -o jsonpath='{.items[*].status.phase}'
          echo

          # Check if all pods are running
          RUNNING_PODS=$(kubectl get pods -n $NAMESPACE -l app=backstage --field-selector=status.phase=Running --no-headers | wc -l)
          TOTAL_PODS=$(kubectl get pods -n $NAMESPACE -l app=backstage --no-headers | wc -l)

          echo "Running pods: $RUNNING_PODS/$TOTAL_PODS"

          if [ "$RUNNING_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -gt 0 ]; then
            echo "✅ All Backstage pods are running"
          else
            echo "❌ Some Backstage pods are not running"
            exit 1
          fi

  # Job to send notifications
  notify:
    runs-on: ubuntu-latest
    needs: [determine-params, verify-deployment]
    if: always() && needs.determine-params.outputs.should_deploy == 'true'
    steps:
      - name: Notify deployment status
        run: |
          ENV="${{ needs.determine-params.outputs.environment }}"
          BU="${{ needs.determine-params.outputs.business_unit }}"
          COUNTRY="${{ needs.determine-params.outputs.country }}"

          if [ "${{ needs.verify-deployment.result }}" = "success" ]; then
            echo "✅ Backstage deployment successful!"
            echo "Environment: $ENV"
            echo "Business Unit: $BU"
            echo "Country: $COUNTRY"
            echo "Access URL: https://backstage.$ENV.msdp.com"
          else
            echo "❌ Backstage deployment failed!"
            echo "Environment: $ENV"
            echo "Business Unit: $BU"
            echo "Country: $COUNTRY"
            echo "Check the logs for details"
          fi
