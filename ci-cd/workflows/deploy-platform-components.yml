name: Deploy Platform Components

on:
  push:
    branches: [dev, test, prod]
    paths:
      - "infrastructure/platforms/**"
      - "ci-cd/workflows/deploy-platform-components.yml"
  pull_request:
    branches: [dev, test, prod]
    paths:
      - "infrastructure/platforms/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - test
          - prod
      component:
        description: "Platform component to deploy"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - networking
          - monitoring
      dry_run:
        description: "Perform dry run"
        required: false
        default: false
        type: boolean

env:
  AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: us-east-1

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      component: ${{ steps.detect.outputs.component }}
      dry_run: ${{ steps.detect.outputs.dry_run }}
    steps:
      - name: Detect Environment
        id: detect
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "component=${{ github.event.inputs.component }}" >> $GITHUB_OUTPUT
            echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
          else
            echo "environment=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "component=all" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
          fi

  load-configuration:
    runs-on: ubuntu-latest
    needs: detect-environment
    outputs:
      cluster_name: ${{ steps.config.outputs.cluster_name }}
      resource_group: ${{ steps.config.outputs.resource_group }}
      domain_base: ${{ steps.config.outputs.domain_base }}
      expected_nginx_version: ${{ steps.config.outputs.expected_nginx_version }}
      expected_cert_manager_version: ${{ steps.config.outputs.expected_cert_manager_version }}
      expected_external_dns_version: ${{ steps.config.outputs.expected_external_dns_version }}
      expected_prometheus_version: ${{ steps.config.outputs.expected_prometheus_version }}
      expected_grafana_version: ${{ steps.config.outputs.expected_grafana_version }}
      deployment_timeout: ${{ steps.config.outputs.deployment_timeout }}
      verification_timeout: ${{ steps.config.outputs.verification_timeout }}
      pod_ready_timeout: ${{ steps.config.outputs.pod_ready_timeout }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load Configuration
        id: config
        run: |
          ENVIRONMENT="${{ needs.detect-environment.outputs.environment }}"
          echo "üîß Loading configuration for environment: $ENVIRONMENT"

          # Load configuration using our script
          source infrastructure/config/load-config-robust.sh "$ENVIRONMENT"

          # Export outputs for other jobs
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "domain_base=$DOMAIN_BASE" >> $GITHUB_OUTPUT
          echo "expected_nginx_version=$EXPECTED_NGINX_VERSION" >> $GITHUB_OUTPUT
          echo "expected_cert_manager_version=$EXPECTED_CERT_MANAGER_VERSION" >> $GITHUB_OUTPUT
          echo "expected_external_dns_version=$EXPECTED_EXTERNAL_DNS_VERSION" >> $GITHUB_OUTPUT
          echo "expected_prometheus_version=$EXPECTED_PROMETHEUS_VERSION" >> $GITHUB_OUTPUT
          echo "expected_grafana_version=$EXPECTED_GRAFANA_VERSION" >> $GITHUB_OUTPUT
          echo "deployment_timeout=$DEPLOYMENT_TIMEOUT" >> $GITHUB_OUTPUT
          echo "verification_timeout=$VERIFICATION_TIMEOUT" >> $GITHUB_OUTPUT
          echo "pod_ready_timeout=$POD_READY_TIMEOUT" >> $GITHUB_OUTPUT

          echo "‚úÖ Configuration loaded successfully"
          echo "üìä Environment: $ENVIRONMENT"
          echo "üèóÔ∏è  Cluster: $CLUSTER_NAME"
          echo "üì¶ Resource Group: $RESOURCE_GROUP"
          echo "üåê Domain: $DOMAIN_BASE"

  validate-platform-components:
    runs-on: ubuntu-latest
    needs: [detect-environment, load-configuration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kubernetes tools
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: "v3.13.0"

      - name: Setup Kustomize
        run: |
          # Install kustomize using direct download
          cd /tmp
          rm -f kustomize
          curl -L "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.0.0/kustomize_v5.0.0_linux_amd64.tar.gz" | tar xz
          sudo mv kustomize /usr/local/bin/
          # Verify installation
          kustomize version

      - name: Validate YAML files
        run: |
          echo "üîç Validating YAML files..."
          find infrastructure/platforms -name "*.yaml" -exec yamllint {} \;

      - name: Validate Kustomize configurations
        run: |
          echo "üîç Validating Kustomize configurations..."
          find infrastructure/platforms -name "kustomization.yaml" -exec kustomize build {} \; > /dev/null

      - name: Validate Helm values
        run: |
          echo "üîç Validating Helm values..."
          find infrastructure/platforms -name "helm-values.yaml" -exec helm template test . -f {} \; > /dev/null

  deploy-networking:
    runs-on: ubuntu-latest
    needs:
      [detect-environment, load-configuration, validate-platform-components]
    if: needs.detect-environment.outputs.component == 'all' || needs.detect-environment.outputs.component == 'networking'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Azure CLI
        uses: azure/login@v1
        with:
          creds: ${{ env.AZURE_CREDENTIALS }}

      - name: Setup Kubernetes tools
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: "v3.13.0"

      - name: Setup Kustomize
        run: |
          # Install kustomize using direct download
          cd /tmp
          rm -f kustomize
          curl -L "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.0.0/kustomize_v5.0.0_linux_amd64.tar.gz" | tar xz
          sudo mv kustomize /usr/local/bin/
          # Verify installation
          kustomize version

      - name: Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ env.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region ${{ env.AWS_REGION }}

      - name: Get AKS credentials
        run: |
          CLUSTER_NAME="${{ needs.load-configuration.outputs.cluster_name }}"
          RESOURCE_GROUP="${{ needs.load-configuration.outputs.resource_group }}"

          echo "üîê Getting AKS credentials for ${CLUSTER_NAME}..."
          echo "üì¶ Resource Group: ${RESOURCE_GROUP}"
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME --overwrite-existing

      - name: Deploy NGINX Ingress Controller
        run: |
          echo "üåê Deploying NGINX Ingress Controller..."
          if [ "${{ needs.detect-environment.outputs.dry_run }}" = "true" ]; then
            kustomize build infrastructure/platforms/networking/nginx-ingress/ | kubectl apply --dry-run=client -f -
          else
            kubectl apply -k infrastructure/platforms/networking/nginx-ingress/
          fi

      - name: Wait for NGINX Ingress Controller
        if: needs.detect-environment.outputs.dry_run != 'true'
        run: |
          echo "‚è≥ Waiting for NGINX Ingress Controller to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=${{ needs.load-configuration.outputs.pod_ready_timeout }}s

      - name: Deploy Cert-Manager
        run: |
          echo "üîí Deploying Cert-Manager..."
          if [ "${{ needs.detect-environment.outputs.dry_run }}" = "true" ]; then
            kustomize build infrastructure/platforms/networking/cert-manager/ | kubectl apply --dry-run=client -f -
          else
            kubectl apply -k infrastructure/platforms/networking/cert-manager/
          fi

      - name: Wait for Cert-Manager
        if: needs.detect-environment.outputs.dry_run != 'true'
        run: |
          echo "‚è≥ Waiting for Cert-Manager to be ready..."
          kubectl wait --namespace cert-manager \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=${{ needs.load-configuration.outputs.pod_ready_timeout }}s

      - name: Deploy External DNS
        run: |
          echo "üåç Deploying External DNS..."
          if [ "${{ needs.detect-environment.outputs.dry_run }}" = "true" ]; then
            kustomize build infrastructure/platforms/networking/external-dns/ | kubectl apply --dry-run=client -f -
          else
            kubectl apply -k infrastructure/platforms/networking/external-dns/
          fi

      - name: Wait for External DNS
        if: needs.detect-environment.outputs.dry_run != 'true'
        run: |
          echo "‚è≥ Waiting for External DNS to be ready..."
          kubectl wait --namespace external-dns \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/name=external-dns \
            --timeout=${{ needs.load-configuration.outputs.pod_ready_timeout }}s

      - name: Verify Platform Components
        if: needs.detect-environment.outputs.dry_run != 'true'
        run: |
          echo "‚úÖ Verifying platform components..."

          echo "üìä NGINX Ingress Controller status:"
          kubectl get pods -n ingress-nginx

          # Verify NGINX version
          NGINX_VERSION=$(kubectl get deployment -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2)
          EXPECTED_NGINX_VERSION="${{ needs.load-configuration.outputs.expected_nginx_version }}"
          echo "üîç NGINX Version: $NGINX_VERSION (Expected: $EXPECTED_NGINX_VERSION)"
          if [[ "$NGINX_VERSION" == *"$EXPECTED_NGINX_VERSION"* ]]; then
            echo "‚úÖ NGINX version matches expected version"
          else
            echo "‚ö†Ô∏è  NGINX version mismatch - expected: $EXPECTED_NGINX_VERSION, got: $NGINX_VERSION"
          fi

          echo "üìä Cert-Manager status:"
          kubectl get pods -n cert-manager
          kubectl get clusterissuer

          # Verify Cert-Manager version
          CERT_MANAGER_VERSION=$(kubectl get deployment -n cert-manager cert-manager -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2)
          EXPECTED_CERT_MANAGER_VERSION="${{ needs.load-configuration.outputs.expected_cert_manager_version }}"
          echo "üîç Cert-Manager Version: $CERT_MANAGER_VERSION (Expected: $EXPECTED_CERT_MANAGER_VERSION)"
          if [[ "$CERT_MANAGER_VERSION" == *"$EXPECTED_CERT_MANAGER_VERSION"* ]]; then
            echo "‚úÖ Cert-Manager version matches expected version"
          else
            echo "‚ö†Ô∏è  Cert-Manager version mismatch - expected: $EXPECTED_CERT_MANAGER_VERSION, got: $CERT_MANAGER_VERSION"
          fi

          echo "üìä External DNS status:"
          kubectl get pods -n external-dns

          # Verify External DNS version
          EXTERNAL_DNS_VERSION=$(kubectl get deployment -n external-dns external-dns -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2)
          EXPECTED_EXTERNAL_DNS_VERSION="${{ needs.load-configuration.outputs.expected_external_dns_version }}"
          echo "üîç External DNS Version: $EXTERNAL_DNS_VERSION (Expected: $EXPECTED_EXTERNAL_DNS_VERSION)"
          if [[ "$EXTERNAL_DNS_VERSION" == *"$EXPECTED_EXTERNAL_DNS_VERSION"* ]]; then
            echo "‚úÖ External DNS version matches expected version"
          else
            echo "‚ö†Ô∏è  External DNS version mismatch - expected: $EXPECTED_EXTERNAL_DNS_VERSION, got: $EXTERNAL_DNS_VERSION"
          fi

  deploy-monitoring:
    runs-on: ubuntu-latest
    needs:
      [detect-environment, load-configuration, validate-platform-components]
    if: needs.detect-environment.outputs.component == 'all' || needs.detect-environment.outputs.component == 'monitoring'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Azure CLI
        uses: azure/login@v1
        with:
          creds: ${{ env.AZURE_CREDENTIALS }}

      - name: Setup Kubernetes tools
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Get AKS credentials
        run: |
          CLUSTER_NAME="${{ needs.load-configuration.outputs.cluster_name }}"
          RESOURCE_GROUP="${{ needs.load-configuration.outputs.resource_group }}"

          echo "üîê Getting AKS credentials for ${CLUSTER_NAME}..."
          echo "üì¶ Resource Group: ${RESOURCE_GROUP}"
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME --overwrite-existing

      - name: Deploy Monitoring Components
        run: |
          echo "üìä Deploying monitoring components..."
          if [ "${{ needs.detect-environment.outputs.dry_run }}" = "true" ]; then
            echo "üîç Dry run mode - monitoring components would be deployed"
          else
            echo "üìä Monitoring components deployment (to be implemented)"
            # TODO: Add monitoring components deployment when available
          fi

  notify-deployment:
    runs-on: ubuntu-latest
    needs:
      [
        detect-environment,
        load-configuration,
        deploy-networking,
        deploy-monitoring,
      ]
    if: always()
    steps:
      - name: Notify Deployment Status
        run: |
          ENVIRONMENT="${{ needs.detect-environment.outputs.environment }}"
          COMPONENT="${{ needs.detect-environment.outputs.component }}"
          CLUSTER_NAME="${{ needs.load-configuration.outputs.cluster_name }}"
          DOMAIN_BASE="${{ needs.load-configuration.outputs.domain_base }}"

          if [ "${{ needs.deploy-networking.result }}" = "success" ] && [ "${{ needs.deploy-monitoring.result }}" = "success" ]; then
            echo "‚úÖ Platform components deployed successfully to ${ENVIRONMENT} environment"
            echo "üèóÔ∏è  Cluster: ${CLUSTER_NAME}"
            echo "üåê Domain: ${DOMAIN_BASE}"
            echo "üì¶ Components deployed: ${COMPONENT}"
            echo "üéØ Configuration-driven deployment completed successfully!"
          else
            echo "‚ùå Platform components deployment failed to ${ENVIRONMENT} environment"
            echo "üèóÔ∏è  Cluster: ${CLUSTER_NAME}"
            echo "üåê Domain: ${DOMAIN_BASE}"
            echo "üîç Check the logs for details"
            exit 1
          fi
