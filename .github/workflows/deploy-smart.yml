name: üß† Smart Deploy - Version-Aware Pipeline

on:
  push:
    branches: [dev, test, prod]
    paths:
      - "infrastructure/**"
      - ".github/workflows/deploy-smart.yml"
  pull_request:
    branches: [test, prod]
    paths:
      - "infrastructure/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - test
          - prod
      force_deploy:
        description: "Force deployment even if versions match"
        required: false
        default: false
        type: boolean

env:
  AZURE_CLIENT_ID: 129dd1fb-3d94-4e10-b451-2b0dea64daee
  AZURE_TENANT_ID: a4474822-c84f-4bd1-bc35-baed17234c9f
  AZURE_SUBSCRIPTION_ID: ecd977ed-b8df-4eb6-9cba-98397e1b2491
  AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
  AWS_REGION: us-east-1

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      cluster_name: ${{ steps.detect.outputs.cluster_name }}
      resource_group: ${{ steps.detect.outputs.resource_group }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
    steps:
      - name: Detect Environment
        id: detect
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            case "${{ github.ref_name }}" in
              dev) ENVIRONMENT="dev" ;;
              test) ENVIRONMENT="test" ;;
              prod) ENVIRONMENT="prod" ;;
              *) ENVIRONMENT="dev" ;;
            esac
          fi
          
          case "$ENVIRONMENT" in
            dev)
              CLUSTER_NAME="msdp-infra-aks"
              RESOURCE_GROUP="delivery-platform-aks-rg"
              ;;
            test)
              CLUSTER_NAME="msdp-infra-aks-test"
              RESOURCE_GROUP="delivery-platform-aks-rg-test"
              ;;
            prod)
              CLUSTER_NAME="msdp-infra-aks-prod"
              RESOURCE_GROUP="delivery-platform-aks-rg-prod"
              ;;
          esac
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT

  check-component-versions:
    needs: detect-environment
    if: needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    outputs:
      deploy_platform: ${{ steps.versions.outputs.deploy_platform }}
      deploy_applications: ${{ steps.versions.outputs.deploy_applications }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.detect-environment.outputs.resource_group }} \
            --name ${{ needs.detect-environment.outputs.cluster_name }} \
            --overwrite-existing

      - name: Check Component Versions
        id: versions
        run: |
          echo "üîç Checking component versions..."
          
          # Define expected versions
          EXPECTED_ARGOCD_VERSION="v2.9.3"
          EXPECTED_GRAFANA_VERSION="10.1.5"
          EXPECTED_CROSSPLANE_VERSION="v1.14.2"
          EXPECTED_CERT_MANAGER_VERSION="v1.13.3"
          EXPECTED_NGINX_VERSION="1.8.2"
          
          DEPLOY_PLATFORM="false"
          DEPLOY_APPLICATIONS="false"
          
          # Check if components exist and get versions
          if kubectl get deployment -n argocd argocd-server >/dev/null 2>&1; then
            CURRENT_ARGOCD=$(kubectl get deployment -n argocd argocd-server -o jsonpath='{.spec.template.spec.containers[0].image}' | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "unknown")
            echo "ArgoCD: Current=$CURRENT_ARGOCD, Expected=$EXPECTED_ARGOCD_VERSION"
            if [ "$CURRENT_ARGOCD" != "$EXPECTED_ARGOCD_VERSION" ] || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
              DEPLOY_APPLICATIONS="true"
            fi
          else
            echo "ArgoCD not found, will deploy"
            DEPLOY_APPLICATIONS="true"
          fi
          
          if kubectl get deployment -n monitoring grafana >/dev/null 2>&1; then
            CURRENT_GRAFANA=$(kubectl get deployment -n monitoring grafana -o jsonpath='{.spec.template.spec.containers[0].image}' | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "unknown")
            echo "Grafana: Current=$CURRENT_GRAFANA, Expected=$EXPECTED_GRAFANA_VERSION"
            if [ "$CURRENT_GRAFANA" != "$EXPECTED_GRAFANA_VERSION" ] || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
              DEPLOY_PLATFORM="true"
            fi
          else
            echo "Grafana not found, will deploy"
            DEPLOY_PLATFORM="true"
          fi
          
          if kubectl get deployment -n crossplane-system crossplane >/dev/null 2>&1; then
            CURRENT_CROSSPLANE=$(kubectl get deployment -n crossplane-system crossplane -o jsonpath='{.spec.template.spec.containers[0].image}' | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "unknown")
            echo "Crossplane: Current=$CURRENT_CROSSPLANE, Expected=$EXPECTED_CROSSPLANE_VERSION"
            if [ "$CURRENT_CROSSPLANE" != "$EXPECTED_CROSSPLANE_VERSION" ] || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
              DEPLOY_APPLICATIONS="true"
            fi
          else
            echo "Crossplane not found, will deploy"
            DEPLOY_APPLICATIONS="true"
          fi
          
          # Check platform components
          if ! kubectl get deployment -n ingress-nginx ingress-nginx-controller >/dev/null 2>&1; then
            echo "NGINX Ingress not found, will deploy"
            DEPLOY_PLATFORM="true"
          fi
          
          if ! kubectl get deployment -n cert-manager cert-manager >/dev/null 2>&1; then
            echo "Cert-Manager not found, will deploy"
            DEPLOY_PLATFORM="true"
          fi
          
          if ! kubectl get deployment -n external-dns external-dns >/dev/null 2>&1; then
            echo "External DNS not found, will deploy"
            DEPLOY_PLATFORM="true"
          fi
          
          if ! kubectl get deployment -n monitoring prometheus-server >/dev/null 2>&1; then
            echo "Prometheus not found, will deploy"
            DEPLOY_PLATFORM="true"
          fi
          
          echo "deploy_platform=$DEPLOY_PLATFORM" >> $GITHUB_OUTPUT
          echo "deploy_applications=$DEPLOY_APPLICATIONS" >> $GITHUB_OUTPUT
          
          echo "üìä Deployment Decision:"
          echo "  Platform Components: $DEPLOY_PLATFORM"
          echo "  Applications: $DEPLOY_APPLICATIONS"

  deploy-platform-components:
    needs: [detect-environment, check-component-versions]
    if: needs.detect-environment.outputs.should_deploy == 'true' && needs.check-component-versions.outputs.deploy_platform == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.detect-environment.outputs.resource_group }} \
            --name ${{ needs.detect-environment.outputs.cluster_name }} \
            --overwrite-existing

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Platform Components
        run: |
          echo "üöÄ Deploying Platform Components (version check passed)"
          
          # Deploy networking components
          kubectl apply -k infrastructure/platforms/networking/nginx-ingress/
          kubectl apply -k infrastructure/platforms/networking/cert-manager/
          kubectl apply -k infrastructure/platforms/networking/external-dns/
          
          # Deploy monitoring components
          kubectl apply -k infrastructure/platforms/monitoring/prometheus/
          kubectl apply -k infrastructure/platforms/monitoring/grafana/
          
          echo "‚úÖ Platform components deployment completed"

  deploy-applications:
    needs: [detect-environment, check-component-versions]
    if: needs.detect-environment.outputs.should_deploy == 'true' && needs.check-component-versions.outputs.deploy_applications == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.detect-environment.outputs.resource_group }} \
            --name ${{ needs.detect-environment.outputs.cluster_name }} \
            --overwrite-existing

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Applications
        run: |
          echo "üöÄ Deploying Applications (version check passed)"
          
          # Deploy applications using unified kustomization
          kubectl apply -k infrastructure/applications/
          
          echo "‚úÖ Applications deployment completed"

  verify-deployment:
    needs: [detect-environment, check-component-versions, deploy-platform-components, deploy-applications]
    if: always() && needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.detect-environment.outputs.resource_group }} \
            --name ${{ needs.detect-environment.outputs.cluster_name }} \
            --overwrite-existing

      - name: Verify Deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Check all components
          echo "üìä Component Status:"
          kubectl get pods -n ingress-nginx
          kubectl get pods -n cert-manager
          kubectl get pods -n external-dns
          kubectl get pods -n monitoring
          kubectl get pods -n argocd
          kubectl get pods -n backstage
          kubectl get pods -n crossplane-system
          
          # Check ArgoCD applications
          echo "üîÑ ArgoCD Applications:"
          kubectl get applications -n argocd
          
          # Test application access
          echo "üåê Testing application access..."
          INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Ingress IP: $INGRESS_IP"
          
          # Test ArgoCD access
          if curl -I -s --max-time 10 "https://argocd.${{ needs.detect-environment.outputs.environment }}.aztech-msdp.com" | grep -q "200\|302"; then
            echo "‚úÖ ArgoCD is accessible"
          else
            echo "‚ùå ArgoCD access failed"
          fi
          
          # Test Grafana access
          if curl -I -s --max-time 10 "https://grafana.${{ needs.detect-environment.outputs.environment }}.aztech-msdp.com" | grep -q "200\|302"; then
            echo "‚úÖ Grafana is accessible"
          else
            echo "‚ùå Grafana access failed"
          fi
          
          echo "‚úÖ Deployment verification completed"
