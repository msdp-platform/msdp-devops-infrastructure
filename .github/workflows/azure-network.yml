name: azure-network
on:
  push:
    branches: [main]
    paths:
      - "infrastructure/environment/azure/network/**"
      - "config/**"
      - "infrastructure/config/**" # include if globals live here
  workflow_dispatch:
    inputs:
      provision_type:
        description: What to manage
        required: true
        default: new_rg_and_vnet
        type: choice
        options: [new_rg_and_vnet, existing_rg_new_vnet, existing_rg_and_vnet]
      action:
        description: plan | apply | destroy
        required: true
        default: plan
        type: choice
        options: [plan, apply, destroy]
      resource_group:
        required: true
      location:
        required: true
        default: westeurope
      vnet_name:
        required: true
        default: msdp-prod-vnet
      address_space:
        description: CSV list (e.g. 10.20.0.0/16)
        required: false
        default: ""
      subnets_json:
        description: JSON array of {name,cidr,nsg_name?}
        required: false
        default: ""
      base_cidr:
        required: false
        default: ""
      subnet_names:
        description: CSV (e.g. app,db,ops)
        required: false
        default: ""
      nsg_prefix:
        description: NSG name prefix (computed mode)
        required: false
        default: ""

permissions:
  id-token: write
  contents: read

env:
  TF_INPUT: "false"
  ARM_USE_OIDC: "true"

jobs:
  apply:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Azure OIDC (for azurerm provider)
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Export ARM env
        run: |
          echo "ARM_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_ENV

      # AWS OIDC (for S3/DynamoDB backend)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: eu-west-1

      - name: Bootstrap environment
        uses: ./.github/actions/bootstrap-env
        with:
          env: dev

      # --- BACKEND: create/ensure S3+DDB and write backend-config.json ---
      - name: Terraform Backend (AWS)
        uses: ./.github/actions/terraform-backend
        with:
          repo-shortname: infra
          project: msdp
          env: dev
          cloud: aws
          cloud-segment: azure # key path segment; keeps state per cloud segment
          app: network # stack name
          function: tfstate
          key-salt: infrastructure/environment/azure/network
          aws-region: eu-west-1
          # optional: pipeline-name: custom-name-here
          # optional: allow-key-mutation: "false"
          use-shared-lock-table: "true"
          # optional: lock-table-name:

      # --- INIT using the generated backend-config.json (safe) ---
      - name: Terraform Init (Reusable)
        uses: ./.github/actions/terraform-init
        with:
          working-directory: infrastructure/environment/azure/network
          terraform-version: 1.13.2
          backend-config-file: ${{ env.TF_BACKEND_CONFIG_FILE }}

      - name: Build network.auto.tfvars.json
        if: ${{ github.event_name == 'workflow_dispatch' }}
        working-directory: infrastructure/environment/azure/network
        shell: bash
        run: |
          set -euo pipefail
          # Basic required inputs
          rg="${{ github.event.inputs.resource_group || '' }}"
          loc="${{ github.event.inputs.location || '' }}"
          vnet="${{ github.event.inputs.vnet_name || '' }}"
          prov="${{ github.event.inputs.provision_type || '' }}"

          if [ -z "$rg" ]; then echo "::error ::resource_group is required"; exit 1; fi
          if [ -z "$vnet" ]; then echo "::error ::vnet_name is required"; exit 1; fi
          if [ -z "$prov" ]; then echo "::error ::provision_type is required"; exit 1; fi
          # derive management flags from provision_type
          case "${{ github.event.inputs.provision_type }}" in
            new_rg_and_vnet)
              manage_rg=true; manage_vnet=true ;;
            existing_rg_new_vnet)
              manage_rg=false; manage_vnet=true ;;
            existing_rg_and_vnet)
              manage_rg=false; manage_vnet=false ;;
            *) echo "Invalid provision_type" >&2; exit 1 ;;
          esac
          addr_csv="${{ github.event.inputs.address_space || '' }}"
          addr_trim=$(printf '%s' "$addr_csv" | tr -d '[:space:]')
          if [ -n "$addr_trim" ]; then
            # explicit mode
            addrs=$(printf '%s\n' "$addr_csv" | tr -s ' ' | tr ',' '\n' | jq -R . | jq -s .)
            # validate at least one CIDR provided
            if [ "$(jq -r 'length' <<< "$addrs")" -lt 1 ]; then
              echo "::error ::address_space must include at least one CIDR (CSV)"; exit 1
            fi
            sj="${{ github.event.inputs.subnets_json || '' }}"
            if [ -n "$sj" ]; then
              # validate JSON
              if ! subnets=$(printf '%s' "$sj" | jq -c .); then
                echo "::error ::subnets_json must be valid JSON array of objects {name,cidr,nsg_name?}"; exit 1
              fi
            else
              subnets='[]'
            fi
            if [ "$(jq -r 'length' <<< "$subnets")" -lt 1 ]; then
              echo "::error ::subnets_json must include at least one subnet"; exit 1
            fi
            jq -n \
              --arg rg "${{ github.event.inputs.resource_group || '' }}" \
              --arg loc "${{ github.event.inputs.location || '' }}" \
              --arg vnet "${{ github.event.inputs.vnet_name || '' }}" \
              --argjson manage_rg "$manage_rg" \
              --argjson manage_vnet "$manage_vnet" \
              --argjson address_space "$addrs" \
              --argjson subnets "$subnets" \
              '{resource_group:$rg, location:$loc, vnet_name:$vnet, manage_resource_group:$manage_rg, manage_vnet:$manage_vnet, address_space:$address_space, subnets:$subnets}' \
              > network.auto.tfvars.json
          else
            # computed mode
            base="${{ github.event.inputs.base_cidr || '' }}"
            if [ -z "$base" ]; then
              echo "::error ::computed mode requires base_cidr (e.g., 10.20.0.0/16)"; exit 1
            fi
            names_csv="${{ github.event.inputs.subnet_names || '' }}"
            if [ -n "$names_csv" ]; then
              names=$(printf '%s\n' "$names_csv" | tr -s ' ' | tr ',' '\n' | jq -R . | jq -s .)
            else
              names='[]'
            fi
            # derive subnet count from names length if provided, else default 0
            count=$(jq -r 'length' <<< "$names")
            if [ "$count" -lt 1 ]; then
              echo "::error ::computed mode requires subnet_names (CSV), e.g., app,db,ops"; exit 1
            fi
            newbits=8
            nsg_prefix="${{ github.event.inputs.nsg_prefix || '' }}"
            jq -n \
              --arg rg "${{ github.event.inputs.resource_group || '' }}" \
              --arg loc "${{ github.event.inputs.location || '' }}" \
              --arg vnet "${{ github.event.inputs.vnet_name || '' }}" \
              --argjson manage_rg "$manage_rg" \
              --argjson manage_vnet "$manage_vnet" \
              --arg base "$base" \
              --argjson count "$count" \
              --argjson newbits "$newbits" \
              --argjson names "$names" \
              --arg nsg_prefix "$nsg_prefix" \
              '{resource_group:$rg, location:$loc, vnet_name:$vnet, manage_resource_group:$manage_rg, manage_vnet:$manage_vnet, base_cidr:$base, subnet_count:$count, subnet_newbits:$newbits, subnet_names:$names, nsg_prefix:$nsg_prefix}' \
              > network.auto.tfvars.json
          fi
          echo "Wrote $(pwd)/network.auto.tfvars.json"

      - name: Terraform plan
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply' }}
        working-directory: infrastructure/environment/azure/network
        run: terraform plan -out=tfplan

      - name: Terraform apply
        if: ${{ (github.event_name != 'workflow_dispatch' && github.ref == 'refs/heads/main' && github.event_name != 'pull_request') || github.event.inputs.action == 'apply' }}
        working-directory: infrastructure/environment/azure/network
        run: terraform apply -auto-approve tfplan || { terraform plan -out=tfplan && terraform apply -auto-approve tfplan; }

      - name: Terraform destroy
        if: ${{ github.event.inputs.action == 'destroy' }}
        working-directory: infrastructure/environment/azure/network
        run: terraform destroy -auto-approve
