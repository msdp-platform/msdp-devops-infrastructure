name: üöÄ Modular Configuration-Driven Pipeline

on:
  push:
    branches: [dev, test, prod]
    paths:
      - "infrastructure/**"
      - ".github/workflows/deploy-modular.yml"
      - ".github/components.yml"
  pull_request:
    branches: [test, prod]
    paths:
      - "infrastructure/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - test
          - prod
      components:
        description: "Components to deploy (comma-separated, or 'all')"
        required: false
        default: "all"
        type: string
      force_deploy:
        description: "Force deployment even if versions match"
        required: false
        default: false
        type: boolean
      dry_run:
        description: "Perform dry run"
        required: false
        default: false
        type: boolean

env:
  AZURE_CLIENT_ID: 129dd1fb-3d94-4e10-b451-2b0dea64daee
  AZURE_TENANT_ID: a4474822-c84f-4bd1-bc35-baed17234c9f
  AZURE_SUBSCRIPTION_ID: ecd977ed-b8df-4eb6-9cba-98397e1b2491
  GITHUB_TOKEN: ${{ github.token }}

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
      components_to_deploy: ${{ steps.components.outputs.components_to_deploy }}
      domain: ${{ steps.env.outputs.domain }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect Environment
        id: env
        run: |
          # Determine environment
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            ENV=$(echo "${{ github.ref_name }}" | sed 's/.*\///')
          fi
          
          # Validate environment
          case $ENV in
            dev|test|prod)
              echo "environment=$ENV" >> $GITHUB_OUTPUT
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "environment=dev" >> $GITHUB_OUTPUT
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              ;;
          esac
          
          # Set domain
          DOMAIN_BASE=$(yq eval '.domains.base' infrastructure/config/global.yaml)
          echo "domain=${ENV}.${DOMAIN_BASE}" >> $GITHUB_OUTPUT
          
          echo "üéØ Environment: $ENV"
          echo "üåê Domain: ${ENV}.${DOMAIN_BASE}"

      - name: Discover Components
        id: components
        run: |
          echo "üîç Discovering components to deploy..."
          
          # Load component registry
          COMPONENTS_JSON=$(yq eval '.components' .github/components.yml -o json)
          
          # Filter components based on input
          if [ "${{ github.event.inputs.components }}" = "" ] || [ "${{ github.event.inputs.components }}" = "all" ]; then
            # Deploy all components except external-dns (unless explicitly requested)
            FILTERED_COMPONENTS=$(echo "$COMPONENTS_JSON" | jq -c 'to_entries | map(select(.key != "external_dns"))')
          else
            # Deploy specific components
            IFS=',' read -ra COMPONENT_LIST <<< "${{ github.event.inputs.components }}"
            # Build a filter condition for each component
            FILTER_CONDITION=""
            for component in "${COMPONENT_LIST[@]}"; do
              if [ -z "$FILTER_CONDITION" ]; then
                FILTER_CONDITION=".key == \"$component\""
              else
                FILTER_CONDITION="$FILTER_CONDITION or .key == \"$component\""
              fi
            done
            FILTERED_COMPONENTS=$(echo "$COMPONENTS_JSON" | jq -c "to_entries | map(select($FILTER_CONDITION))")
          fi
          
          # Ensure proper JSON formatting for GitHub Actions matrix
          echo "components_to_deploy=$FILTERED_COMPONENTS" >> $GITHUB_OUTPUT
          
          echo "üìã Components to deploy:"
          echo "$FILTERED_COMPONENTS" | jq -r '.[].key'

  deploy-platform-components:
    needs: detect-environment
    if: needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    strategy:
      fail-fast: false
      matrix:
        component: ${{ fromJson(needs.detect-environment.outputs.components_to_deploy) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          azure_client_id: ${{ env.AZURE_CLIENT_ID }}
          azure_tenant_id: ${{ env.AZURE_TENANT_ID }}
          azure_subscription_id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          environment: ${{ needs.detect-environment.outputs.environment }}

      - name: Deploy Helm Component
        if: matrix.component.value.type == 'helm'
        uses: ./.github/actions/deploy-helm-component
        with:
          component_name: ${{ matrix.component.key }}
          component_config: ${{ toJson(matrix.component.value) }}
          environment: ${{ needs.detect-environment.outputs.environment }}
          dry_run: ${{ github.event.inputs.dry_run || 'false' }}

      - name: Deploy YAML Component
        if: matrix.component.value.type == 'yaml'
        uses: ./.github/actions/deploy-yaml-component
        with:
          component_name: ${{ matrix.component.key }}
          component_config: ${{ toJson(matrix.component.value) }}
          environment: ${{ needs.detect-environment.outputs.environment }}
          dry_run: ${{ github.event.inputs.dry_run || 'false' }}

  verify-deployment:
    needs: [detect-environment, deploy-platform-components]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          azure_client_id: ${{ env.AZURE_CLIENT_ID }}
          azure_tenant_id: ${{ env.AZURE_TENANT_ID }}
          azure_subscription_id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          environment: ${{ needs.detect-environment.outputs.environment }}

      - name: Verify All Components
        run: |
          echo "üîç Verifying all deployed components..."
          
          # Check all namespaces
          echo "üìä All namespaces:"
          kubectl get namespaces
          
          # Check external-dns (should be preserved)
          echo "üìä External DNS status:"
          kubectl get pods -n external-dns
          kubectl logs deployment/external-dns -n external-dns --tail=3
          
          # Check deployed components
          COMPONENTS='${{ needs.detect-environment.outputs.components_to_deploy }}'
          echo "$COMPONENTS" | jq -r '.[].key' | while read component; do
            namespace=$(echo "$COMPONENTS" | jq -r ".[] | select(.key == \"$component\") | .value.namespace")
            echo "üìä $component (namespace: $namespace):"
            kubectl get pods -n "$namespace" 2>/dev/null || echo "  No pods found"
            kubectl get svc -n "$namespace" 2>/dev/null || echo "  No services found"
            kubectl get ingress -n "$namespace" 2>/dev/null || echo "  No ingress found"
          done
          
          echo "‚úÖ Verification completed"

      - name: Test Component Access
        run: |
          echo "üåê Testing component access..."
          
          # Get ingress IP
          INGRESS_IP=""
          if kubectl get svc -n ingress-nginx ingress-nginx-controller >/dev/null 2>&1; then
            INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          fi
          
          if [ -n "$INGRESS_IP" ]; then
            echo "üîó Ingress IP: $INGRESS_IP"
            
            # Test ingress endpoints
            DOMAIN="${{ needs.detect-environment.outputs.domain }}"
            
            for service in argocd grafana prometheus; do
              if kubectl get ingress -A | grep -q "$service"; then
                echo "Testing $service.$DOMAIN..."
                curl -I -s --max-time 10 "https://$service.$DOMAIN" || echo "  ‚ö†Ô∏è $service not accessible yet"
              fi
            done
          else
            echo "‚ÑπÔ∏è No ingress controller found, skipping access tests"
          fi
          
          echo "‚úÖ Access testing completed"

  post-deployment-certificate-management:
    needs: [detect-environment, deploy-platform-components]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          azure_client_id: ${{ env.AZURE_CLIENT_ID }}
          azure_tenant_id: ${{ env.AZURE_TENANT_ID }}
          azure_subscription_id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          environment: ${{ needs.detect-environment.outputs.environment }}

      - name: Wait for External Secrets to be Ready
        run: |
          echo "‚è≥ Waiting for External Secrets Operator to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=external-secrets -n external-secrets --timeout=300s
          echo "‚úÖ External Secrets Operator is ready"

      - name: Discover HTTPS Ingress Rules
        run: |
          echo "üîç Discovering HTTPS ingress rules..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"
          ./scripts/discover-https-ingress.sh "${{ needs.detect-environment.outputs.environment }}" "aztech-msdp.com" "$TEMP_DIR"
          echo "‚úÖ HTTPS ingress discovery complete"

      - name: Apply Certificate Resources
        run: |
          echo "üîß Applying Certificate resources for cert-manager..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"
          find "$TEMP_DIR" -name "*-certificate.yaml" -exec kubectl apply -f {} \;
          echo "‚úÖ Certificate resources applied"

      - name: Wait for Certificate Generation
        run: |
          echo "‚è≥ Waiting for certificates to be generated by cert-manager..."
          sleep 60
          echo "‚úÖ Certificate generation wait complete"

      - name: Sync Certificates to Azure Key Vault
        run: |
          echo "üîÑ Syncing certificates to Azure Key Vault..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"
          ./scripts/sync-certificates-to-keyvault.sh "${{ needs.detect-environment.outputs.environment }}" "msdp-certificates-kv" "$TEMP_DIR"
          echo "‚úÖ Certificate sync to Key Vault complete"

      - name: Apply ExternalSecret Resources
        run: |
          echo "üîß Applying ExternalSecret resources..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"
          find "$TEMP_DIR" -name "*-externalsecret.yaml" -exec kubectl apply -f {} \;
          echo "‚úÖ ExternalSecret resources applied"

      - name: Verify Certificate Management
        run: |
          echo "üîç Verifying certificate management..."
          
          # Check External Secrets status
          echo "üìä External Secrets status:"
          kubectl get externalsecrets -A
          
          # Check certificate sync status
          echo "üìä Certificate sync status:"
          kubectl get secrets -A | grep tls
          
          echo "‚úÖ Certificate management verification complete"
