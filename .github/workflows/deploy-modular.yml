name: ğŸš€ Modular Configuration-Driven Pipeline

on:
  push:
    branches: [dev, test, prod]
    paths:
      - "infrastructure/**"
      - ".github/workflows/deploy-modular.yml"
      - ".github/components.yml"
  pull_request:
    branches: [test, prod]
    paths:
      - "infrastructure/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - test
          - prod
      components:
        description: "Components to deploy (comma-separated, or 'all')"
        required: false
        default: "all"
        type: string
      force_deploy:
        description: "Force deployment even if versions match"
        required: false
        default: false
        type: boolean
      dry_run:
        description: "Perform dry run"
        required: false
        default: false
        type: boolean

env:
  AZURE_CLIENT_ID: 129dd1fb-3d94-4e10-b451-2b0dea64daee
  AZURE_TENANT_ID: a4474822-c84f-4bd1-bc35-baed17234c9f
  AZURE_SUBSCRIPTION_ID: ecd977ed-b8df-4eb6-9cba-98397e1b2491
  GITHUB_TOKEN: ${{ github.token }}

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
      components_to_deploy: ${{ steps.components.outputs.components_to_deploy }}
      domain: ${{ steps.env.outputs.domain }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect Environment
        id: env
        run: |
          # Determine environment
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            ENV=$(echo "${{ github.ref_name }}" | sed 's/.*\///')
          fi

          # Validate environment
          case $ENV in
            dev|test|prod)
              echo "environment=$ENV" >> $GITHUB_OUTPUT
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "environment=dev" >> $GITHUB_OUTPUT
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              ;;
          esac

          # Set domain
          DOMAIN_BASE=$(yq eval '.domains.base' infrastructure/config/global.yaml)
          echo "domain=${ENV}.${DOMAIN_BASE}" >> $GITHUB_OUTPUT

          echo "ğŸ¯ Environment: $ENV"
          echo "ğŸŒ Domain: ${ENV}.${DOMAIN_BASE}"

      - name: Discover Components
        id: components
        run: |
          echo "ğŸ” Discovering components to deploy..."

          # Load component registry
          COMPONENTS_JSON=$(yq eval '.components' .github/components.yml -o json)

          # Filter components based on input
          if [ "${{ github.event.inputs.components }}" = "" ] || [ "${{ github.event.inputs.components }}" = "all" ]; then
            # Deploy all components except external-dns (unless explicitly requested)
            FILTERED_COMPONENTS=$(echo "$COMPONENTS_JSON" | jq -c 'to_entries | map(select(.key != "external_dns"))')
          else
            # Deploy specific components
            IFS=',' read -ra COMPONENT_LIST <<< "${{ github.event.inputs.components }}"
            # Build a filter condition for each component
            FILTER_CONDITION=""
            for component in "${COMPONENT_LIST[@]}"; do
              if [ -z "$FILTER_CONDITION" ]; then
                FILTER_CONDITION=".key == \"$component\""
              else
                FILTER_CONDITION="$FILTER_CONDITION or .key == \"$component\""
              fi
            done
            FILTERED_COMPONENTS=$(echo "$COMPONENTS_JSON" | jq -c "to_entries | map(select($FILTER_CONDITION))")
          fi

          # Ensure proper JSON formatting for GitHub Actions matrix
          echo "components_to_deploy=$FILTERED_COMPONENTS" >> $GITHUB_OUTPUT

          echo "ğŸ“‹ Components to deploy:"
          echo "$FILTERED_COMPONENTS" | jq -r '.[].key'

  deploy-platform-components:
    needs: detect-environment
    if: needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    strategy:
      fail-fast: false
      matrix:
        component: ${{ fromJson(needs.detect-environment.outputs.components_to_deploy) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          azure_client_id: ${{ env.AZURE_CLIENT_ID }}
          azure_tenant_id: ${{ env.AZURE_TENANT_ID }}
          azure_subscription_id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          environment: ${{ needs.detect-environment.outputs.environment }}

      - name: Deploy Helm Component
        if: matrix.component.value.type == 'helm'
        uses: ./.github/actions/deploy-helm-component
        with:
          component_name: ${{ matrix.component.key }}
          component_config: ${{ toJson(matrix.component.value) }}
          environment: ${{ needs.detect-environment.outputs.environment }}
          dry_run: ${{ github.event.inputs.dry_run || 'false' }}

      - name: Deploy YAML Component
        if: matrix.component.value.type == 'yaml'
        uses: ./.github/actions/deploy-yaml-component
        with:
          component_name: ${{ matrix.component.key }}
          component_config: ${{ toJson(matrix.component.value) }}
          environment: ${{ needs.detect-environment.outputs.environment }}
          dry_run: ${{ github.event.inputs.dry_run || 'false' }}

  verify-deployment:
    needs: [detect-environment, deploy-platform-components]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          azure_client_id: ${{ env.AZURE_CLIENT_ID }}
          azure_tenant_id: ${{ env.AZURE_TENANT_ID }}
          azure_subscription_id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          environment: ${{ needs.detect-environment.outputs.environment }}

      - name: Verify All Components
        run: |
          echo "ğŸ” Verifying all deployed components..."

          # Check all namespaces
          echo "ğŸ“Š All namespaces:"
          kubectl get namespaces

          # Check external-dns (should be preserved)
          echo "ğŸ“Š External DNS status:"
          kubectl get pods -n external-dns
          kubectl logs deployment/external-dns -n external-dns --tail=3

          # Check deployed components
          COMPONENTS='${{ needs.detect-environment.outputs.components_to_deploy }}'
          echo "$COMPONENTS" | jq -r '.[].key' | while read component; do
            namespace=$(echo "$COMPONENTS" | jq -r ".[] | select(.key == \"$component\") | .value.namespace")
            echo "ğŸ“Š $component (namespace: $namespace):"
            kubectl get pods -n "$namespace" 2>/dev/null || echo "  No pods found"
            kubectl get svc -n "$namespace" 2>/dev/null || echo "  No services found"
            kubectl get ingress -n "$namespace" 2>/dev/null || echo "  No ingress found"
          done

          echo "âœ… Verification completed"

      - name: Display Ingress Information
        run: |
          echo "ğŸŒ Ingress Information:"
          
          # Get ingress IP
          INGRESS_IP=""
          if kubectl get svc -n ingress-nginx ingress-nginx-controller >/dev/null 2>&1; then
            INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          fi

          if [ -n "$INGRESS_IP" ]; then
            echo "ğŸ”— Ingress IP: $INGRESS_IP"
            echo "ğŸŒ Access URLs:"
            DOMAIN="${{ needs.detect-environment.outputs.domain }}"
            echo "  - ArgoCD: https://argocd.$DOMAIN"
            echo "  - Grafana: https://grafana.$DOMAIN"
            echo "  - Prometheus: https://prometheus.$DOMAIN"
          else
            echo "â„¹ï¸ Ingress controller not ready yet"
          fi

          echo "âœ… Ingress information displayed"

  post-deployment-certificate-management:
    needs: [detect-environment, deploy-platform-components]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          azure_client_id: ${{ env.AZURE_CLIENT_ID }}
          azure_tenant_id: ${{ env.AZURE_TENANT_ID }}
          azure_subscription_id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          environment: ${{ needs.detect-environment.outputs.environment }}

      - name: Wait for External Secrets to be Ready
        run: |
          echo "â³ Waiting for External Secrets Operator to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=external-secrets -n external-secrets --timeout=300s
          echo "âœ… External Secrets Operator is ready"

      - name: Discover HTTPS Ingress Rules
        run: |
          echo "ğŸ” Discovering HTTPS ingress rules..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"
          ./scripts/discover-https-ingress.sh "${{ needs.detect-environment.outputs.environment }}" "aztech-msdp.com" "$TEMP_DIR"
          echo "âœ… HTTPS ingress discovery complete"

      - name: Validate Generated Certificate Resources
        run: |
          echo "ğŸ” Validating generated certificate resources..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"

          # Validate YAML files
          for cert_file in "$TEMP_DIR"/*-certificate.yaml; do
            if [ -f "$cert_file" ]; then
              echo "ğŸ“„ Validating: $cert_file"
              if yq eval '.' "$cert_file" >/dev/null 2>&1; then
                echo "âœ… Valid YAML: $cert_file"
              else
                echo "âŒ Invalid YAML: $cert_file"
                echo "Content:"
                cat "$cert_file"
                exit 1
              fi
            fi
          done
          echo "âœ… All certificate resources are valid"

      - name: Apply Certificate Resources
        run: |
          echo "ğŸ”§ Applying Certificate resources for cert-manager..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"
          find "$TEMP_DIR" -name "*-certificate.yaml" -exec kubectl apply -f {} \;
          echo "âœ… Certificate resources applied"

      - name: Wait for Certificate Generation
        run: |
          echo "â³ Waiting for certificates to be generated by cert-manager..."
          sleep 60
          echo "âœ… Certificate generation wait complete"

      - name: Apply ExternalSecret Resources
        run: |
          echo "ğŸ”§ Applying ExternalSecret resources..."
          TEMP_DIR="/tmp/certificate-management-${{ needs.detect-environment.outputs.environment }}"
          find "$TEMP_DIR" -name "*-externalsecret.yaml" -exec kubectl apply -f {} \;
          echo "âœ… ExternalSecret resources applied"

      - name: Verify Certificate Management
        run: |
          echo "ğŸ” Verifying certificate management..."

          # Check External Secrets status
          echo "ğŸ“Š External Secrets status:"
          kubectl get externalsecrets -A

          # Check certificate sync status
          echo "ğŸ“Š Certificate sync status:"
          kubectl get secrets -A | grep tls

          echo "âœ… Certificate management verification complete"
