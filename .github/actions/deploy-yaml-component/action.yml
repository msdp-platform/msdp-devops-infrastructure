name: 'Deploy YAML Component'
description: 'Deploy a component using Kustomize/YAML manifests'

inputs:
  component_name:
    description: 'Component name'
    required: true
  component_config:
    description: 'Component configuration JSON'
    required: true
  environment:
    description: 'Environment name'
    required: true
  dry_run:
    description: 'Perform dry run'
    required: false
    default: 'false'
  github_token:
    description: 'GitHub token for API access'
    required: false
    default: ${{ github.token }}

runs:
  using: 'composite'
  steps:
    - name: Parse Component Configuration
      id: parse
      shell: bash
      run: |
        echo "üîß Parsing YAML component configuration for ${{ inputs.component_name }}..."
        
        # Parse the component config JSON
        echo '${{ inputs.component_config }}' > /tmp/component.json
        
        COMPONENT_PATH=$(jq -r '.path' /tmp/component.json)
        NAMESPACE=$(jq -r '.namespace' /tmp/component.json)
        CATEGORY=$(jq -r '.category' /tmp/component.json)
        
        echo "path=$COMPONENT_PATH" >> $GITHUB_OUTPUT
        echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
        echo "category=$CATEGORY" >> $GITHUB_OUTPUT
        
        echo "üìã Component details:"
        echo "  Path: $COMPONENT_PATH"
        echo "  Namespace: $NAMESPACE"
        echo "  Category: $CATEGORY"

    - name: Setup Kustomize
      shell: bash
      run: |
        echo "üîß Setting up Kustomize..."
        
        # Install kustomize if not available
        if ! command -v kustomize &> /dev/null; then
          cd /tmp
          curl -L "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.0.0/kustomize_v5.0.0_linux_amd64.tar.gz" | tar xz
          sudo mv kustomize /usr/local/bin/
        fi
        
        kustomize version

    - name: Create Required Secrets
      shell: bash
      run: |
        echo "üîê Creating required secrets for ${{ inputs.component_name }}..."
        
        NAMESPACE="${{ steps.parse.outputs.namespace }}"
        COMPONENT="${{ inputs.component_name }}"
        
        # Create namespace first
        kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
        
        case "$COMPONENT" in
          "external_dns")
            echo "‚ÑπÔ∏è External DNS secrets managed separately"
            ;;
          "backstage")
            # Create backstage secrets if needed
            if ! kubectl get secret backstage-secrets -n "$NAMESPACE" >/dev/null 2>&1; then
              kubectl create secret generic backstage-secrets \
                --namespace="$NAMESPACE" \
                --from-literal=postgres-password="$(openssl rand -base64 32)" \
                --from-literal=github-token="${{ inputs.github_token }}"
              echo "‚úÖ Created backstage-secrets"
            else
              echo "‚úÖ backstage-secrets already exists"
            fi
            ;;
          *)
            echo "‚ÑπÔ∏è No special secrets required for $COMPONENT"
            ;;
        esac

    - name: Deploy YAML Component
      shell: bash
      run: |
        echo "üöÄ Deploying ${{ inputs.component_name }}..."
        
        COMPONENT_PATH="${{ steps.parse.outputs.path }}"
        
        if [ ! -d "$COMPONENT_PATH" ]; then
          echo "‚ùå Component path not found: $COMPONENT_PATH"
          exit 1
        fi
        
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "üîç DRY RUN MODE"
          if [ -f "$COMPONENT_PATH/kustomization.yaml" ]; then
            kubectl kustomize "$COMPONENT_PATH" | kubectl apply --dry-run=client -f -
          else
            kubectl apply --dry-run=client -f "$COMPONENT_PATH/"
          fi
        else
          if [ -f "$COMPONENT_PATH/kustomization.yaml" ]; then
            kubectl apply -k "$COMPONENT_PATH"
          else
            kubectl apply -f "$COMPONENT_PATH/"
          fi
          
          echo "‚úÖ Successfully deployed ${{ inputs.component_name }}"
        fi

    - name: Wait for Deployment
      if: inputs.dry_run != 'true'
      shell: bash
      run: |
        echo "‚è≥ Waiting for ${{ inputs.component_name }} to be ready..."
        
        NAMESPACE="${{ steps.parse.outputs.namespace }}"
        
        # Wait for pods to be ready (with timeout)
        timeout 300s bash -c "
          while ! kubectl get pods -n '$NAMESPACE' -l 'app.kubernetes.io/name=${{ inputs.component_name }}' --no-headers | grep -q Running; do
            echo 'Waiting for pods...'
            sleep 10
          done
        " || {
          echo "‚ö†Ô∏è Timeout waiting for pods, checking status..."
          kubectl get pods -n "$NAMESPACE" -o wide
          kubectl describe pods -n "$NAMESPACE"
          echo "‚ö†Ô∏è Continuing anyway..."
        }

    - name: Verify Deployment
      if: inputs.dry_run != 'true'
      shell: bash
      run: |
        echo "üîç Verifying deployment of ${{ inputs.component_name }}..."
        
        NAMESPACE="${{ steps.parse.outputs.namespace }}"
        
        # Check all resources
        echo "üìä Pods:"
        kubectl get pods -n "$NAMESPACE"
        
        echo "üìä Services:"
        kubectl get svc -n "$NAMESPACE" || echo "‚ÑπÔ∏è No services found"
        
        echo "üìä Ingress:"
        kubectl get ingress -n "$NAMESPACE" || echo "‚ÑπÔ∏è No ingress found"
        
        echo "üìä Deployments:"
        kubectl get deployments -n "$NAMESPACE" || echo "‚ÑπÔ∏è No deployments found"
        
        echo "‚úÖ Verification complete for ${{ inputs.component_name }}"
