name: "Deploy Helm Component"
description: "Deploy a component using Helm with configuration merging"

inputs:
  component_name:
    description: "Component name"
    required: true
  component_config:
    description: "Component configuration JSON"
    required: true
  environment:
    description: "Environment name"
    required: true
  dry_run:
    description: "Perform dry run"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Parse Component Configuration
      id: parse
      shell: bash
      run: |
        echo "üîß Parsing component configuration for ${{ inputs.component_name }}..."

        # Parse the component config JSON
        echo '${{ inputs.component_config }}' > /tmp/component.json

        CHART=$(jq -r '.chart' /tmp/component.json)
        REPOSITORY=$(jq -r '.repository' /tmp/component.json)
        NAMESPACE=$(jq -r '.namespace' /tmp/component.json)
        CHART_VERSION=$(jq -r '.chart_version' /tmp/component.json)
        CATEGORY=$(jq -r '.category' /tmp/component.json)

        echo "chart=$CHART" >> $GITHUB_OUTPUT
        echo "repository=$REPOSITORY" >> $GITHUB_OUTPUT
        echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
        echo "chart_version=$CHART_VERSION" >> $GITHUB_OUTPUT
        echo "category=$CATEGORY" >> $GITHUB_OUTPUT

        echo "üìã Component details:"
        echo "  Chart: $CHART"
        echo "  Repository: $REPOSITORY"
        echo "  Namespace: $NAMESPACE"
        echo "  Version: $CHART_VERSION"

    - name: Setup Helm Repository
      shell: bash
      run: |
        echo "üì¶ Setting up Helm repository for ${{ inputs.component_name }}..."

        CHART="${{ steps.parse.outputs.chart }}"
        REPO_URL="${{ steps.parse.outputs.repository }}"

        # Check if this is an OCI chart
        if [[ "$CHART" == oci://* ]]; then
          echo "üîß Detected OCI chart: $CHART"
          echo "‚úÖ OCI chart detected - no repository setup needed"
        else
          echo "üì¶ Setting up traditional Helm repository..."
          REPO_NAME="${{ inputs.component_name }}-repo"
          
          # Add repository
          helm repo add "$REPO_NAME" "$REPO_URL"
          helm repo update
          
          echo "‚úÖ Repository added: $REPO_NAME -> $REPO_URL"
        fi

    - name: Generate Component Values
      id: values
      shell: bash
      run: |
        echo "üîß Generating values for ${{ inputs.component_name }}..."

        COMPONENT="${{ inputs.component_name }}"
        ENV="${{ inputs.environment }}"
        VALUES_FILE="/tmp/${COMPONENT}-values.yaml"

        # Start with global component config
        GLOBAL_CONFIG="infrastructure/config/global.yaml"
        ENV_CONFIG="infrastructure/config/environments/${ENV}.yaml"
        COMPONENT_CONFIG="infrastructure/config/components/${COMPONENT}.yaml"

        # Create base values from global config
        yq eval ".platform_components.${COMPONENT} // .applications.${COMPONENT}" "$GLOBAL_CONFIG" > "$VALUES_FILE"

        # Merge environment overrides if they exist
        if [ -f "$ENV_CONFIG" ] && yq eval ".overrides.${COMPONENT}" "$ENV_CONFIG" | grep -v "null"; then
          yq eval-all 'select(fileIndex == 0) * select(fileIndex == 1)' \
            "$VALUES_FILE" \
            <(yq eval ".overrides.${COMPONENT}" "$ENV_CONFIG") > "${VALUES_FILE}.tmp"
          mv "${VALUES_FILE}.tmp" "$VALUES_FILE"
        fi

        # Add environment-specific settings
        DOMAIN="${{ inputs.environment }}.$(yq eval '.domains.base' $GLOBAL_CONFIG)"

        # Component-specific domain configuration
        case "$COMPONENT" in
          "grafana")
            yq eval ".ingress.hosts[0] = \"grafana.$DOMAIN\"" -i "$VALUES_FILE"
            yq eval ".ingress.enabled = true" -i "$VALUES_FILE"
            ;;
          "argocd")
            yq eval ".server.ingress.hosts[0] = \"argocd.$DOMAIN\"" -i "$VALUES_FILE"
            yq eval ".server.ingress.enabled = true" -i "$VALUES_FILE"
            ;;
          "prometheus")
            yq eval ".prometheus.ingress.hosts[0] = \"prometheus.$DOMAIN\"" -i "$VALUES_FILE"
            yq eval ".prometheus.ingress.enabled = true" -i "$VALUES_FILE"
            ;;
        esac

        echo "values_file=$VALUES_FILE" >> $GITHUB_OUTPUT

        echo "üìù Generated values file: $VALUES_FILE"
        echo "üîç Values preview:"
        head -20 "$VALUES_FILE"

    - name: Create Namespace
      shell: bash
      run: |
        echo "üìÅ Creating namespace: ${{ steps.parse.outputs.namespace }}"

        # Ensure we're using the correct kubeconfig
        if [ -z "$KUBECONFIG" ]; then
          echo "‚ö†Ô∏è KUBECONFIG not set, using default"
        else
          echo "‚úÖ Using KUBECONFIG: $KUBECONFIG"
        fi

        kubectl create namespace "${{ steps.parse.outputs.namespace }}" --dry-run=client -o yaml | kubectl apply -f -

    - name: Create Required Secrets
      shell: bash
      run: |
        echo "üîê Creating required secrets for ${{ inputs.component_name }}..."

        NAMESPACE="${{ steps.parse.outputs.namespace }}"
        COMPONENT="${{ inputs.component_name }}"

        case "$COMPONENT" in
          "grafana")
            if ! kubectl get secret grafana-admin-secret -n "$NAMESPACE" >/dev/null 2>&1; then
              kubectl create secret generic grafana-admin-secret \
                --namespace="$NAMESPACE" \
                --from-literal=admin-user=admin \
                --from-literal=admin-password="$(openssl rand -base64 32)"
              echo "‚úÖ Created grafana-admin-secret"
            else
              echo "‚úÖ grafana-admin-secret already exists"
            fi
            ;;
          *)
            echo "‚ÑπÔ∏è No special secrets required for $COMPONENT"
            ;;
        esac

    - name: Deploy Helm Chart
      shell: bash
      run: |
        echo "üöÄ Deploying ${{ inputs.component_name }}..."

        # Convert component name to valid Helm release name (replace underscores with hyphens)
        RELEASE_NAME=$(echo "${{ inputs.component_name }}" | tr '_' '-')
        REPO_NAME="${{ inputs.component_name }}-repo"
        CHART="${{ steps.parse.outputs.chart }}"
        NAMESPACE="${{ steps.parse.outputs.namespace }}"
        CHART_VERSION="${{ steps.parse.outputs.chart_version }}"
        VALUES_FILE="${{ steps.values.outputs.values_file }}"

        echo "üìã Release name: $RELEASE_NAME (converted from ${{ inputs.component_name }})"

        # Check if this is an OCI chart
        if [[ "$CHART" == oci://* ]]; then
          echo "üîß Deploying OCI chart: $CHART"
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN MODE"
            helm install "$RELEASE_NAME" "$CHART" \
              --namespace "$NAMESPACE" \
              --version "$CHART_VERSION" \
              --values "$VALUES_FILE" \
              --dry-run --debug
          else
            helm upgrade --install "$RELEASE_NAME" "$CHART" \
              --namespace "$NAMESPACE" \
              --version "$CHART_VERSION" \
              --values "$VALUES_FILE" \
              --wait --timeout=10m \
              --create-namespace
            
            echo "‚úÖ Successfully deployed ${{ inputs.component_name }} as $RELEASE_NAME (OCI chart)"
          fi
        else
          echo "üì¶ Deploying traditional Helm chart: $REPO_NAME/$CHART"
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN MODE"
            helm install "$RELEASE_NAME" "$REPO_NAME/$CHART" \
              --namespace "$NAMESPACE" \
              --version "$CHART_VERSION" \
              --values "$VALUES_FILE" \
              --dry-run --debug
          else
            helm upgrade --install "$RELEASE_NAME" "$REPO_NAME/$CHART" \
              --namespace "$NAMESPACE" \
              --version "$CHART_VERSION" \
              --values "$VALUES_FILE" \
              --wait --timeout=10m \
              --create-namespace
            
            echo "‚úÖ Successfully deployed ${{ inputs.component_name }} as $RELEASE_NAME"
          fi
        fi

        # Post-deployment steps for specific components
        case "${{ inputs.component_name }}" in
          "cert_manager")
            echo "üîß Applying ClusterIssuer for cert-manager..."
            # Wait for cert-manager to be ready
            kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=cert-manager -n "${{ steps.parse.outputs.namespace }}" --timeout=300s
            # Apply ClusterIssuer
            kubectl apply -f infrastructure/platforms/networking/cert-manager/cluster-issuer.yaml
            echo "‚úÖ ClusterIssuer applied successfully"
            ;;
          "external_secrets")
            echo "üîß External Secrets deployed with Azure OIDC integration..."
            # Wait for External Secrets to be ready
            kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=external-secrets -n "${{ steps.parse.outputs.namespace }}" --timeout=300s
            
            # Apply ClusterSecretStore
            echo "üîß Applying ClusterSecretStore..."
            kubectl apply -f infrastructure/platforms/security/external-secrets/azure-keyvault-store.yaml
            
            # Discover HTTPS ingress rules and generate certificate management
            echo "üîç Discovering HTTPS ingress rules..."
            TEMP_DIR="/tmp/certificate-management-${{ inputs.environment }}"
            ./scripts/discover-https-ingress.sh "${{ inputs.environment }}" "aztech-msdp.com" "$TEMP_DIR"
            
            # Apply Certificate resources for cert-manager
            echo "üîß Applying Certificate resources..."
            find "$TEMP_DIR" -name "*-certificate.yaml" -exec kubectl apply -f {} \;
            
            # Wait for certificates to be generated
            echo "‚è≥ Waiting for certificates to be generated..."
            sleep 30
            
            # Sync certificates to Azure Key Vault
            echo "üîÑ Syncing certificates to Azure Key Vault..."
            ./scripts/sync-certificates-to-keyvault.sh "${{ inputs.environment }}" "msdp-certificates-kv" "$TEMP_DIR"
            
            # Apply ExternalSecret resources
            echo "üîß Applying ExternalSecret resources..."
            find "$TEMP_DIR" -name "*-externalsecret.yaml" -exec kubectl apply -f {} \;
            
            echo "‚úÖ External Secrets integration resources applied successfully"
            ;;
        esac

    - name: Verify Deployment
      if: inputs.dry_run != 'true'
      shell: bash
      run: |
        echo "üîç Verifying deployment of ${{ inputs.component_name }}..."

        NAMESPACE="${{ steps.parse.outputs.namespace }}"

        # Check pods
        kubectl get pods -n "$NAMESPACE" -l "app.kubernetes.io/name=${{ inputs.component_name }}"

        # Check services
        kubectl get svc -n "$NAMESPACE"

        # Check ingress if it should exist
        kubectl get ingress -n "$NAMESPACE" || echo "‚ÑπÔ∏è No ingress found (may be normal)"

        echo "‚úÖ Verification complete for ${{ inputs.component_name }}"
